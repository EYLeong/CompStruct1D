module mojo_top (
    input clk,              // 50MHz clock
    input rst_n,            // reset button (active low)
    output led[8],         // 8 user controllable LEDs
    input cclk,             // configuration clock, AVR ready when high
    output spi_miso,        // AVR SPI MISO
    input spi_ss,           // AVR SPI Slave Select
    input spi_mosi,         // AVR SPI MOSI
    input spi_sck,          // AVR SPI Clock
    output spi_channel [4], // AVR general purpose pins (used by default to select ADC channel)
    input avr_tx,           // AVR TX (FPGA RX)
    output avr_rx,          // AVR RX (FPGA TX)
    input avr_rx_busy,       // AVR RX buffer full
    output io_sel[4],
    output io_seg[8],
    output io_led[24],
    
    input p1Raw[4],
    input p2Raw[4],
    input start,
    output p1LED[4],
    output p2LED[4]
    
  ) {
  
  sig rst;                  // reset signal
  sig instruction[17]; // 17bit instruction to cpu
  sig p1input[4]; // 4bit button inputs that have been conditioned
  sig p2input[4];
  sig p1ideal[6]; // current sequence that each player is supposed to press
  sig p2ideal[6];
  sig dynamicRst1; // Dynamic reset signals for player score deduction counters
  sig dynamicRst2;
  sig startCounterRst;
  
  .clk(clk) {
    // The reset conditioner is used to synchronize the reset signal to the FPGA
    // clock. This ensures the entire FPGA comes out of reset at the same time.
    reset_conditioner reset_cond;
    
    // button conditioning
    button_conditioner p1c1;
    button_conditioner p1c2;
    button_conditioner p1c3;
    button_conditioner p1c4;
    
    button_conditioner p2c1;
    button_conditioner p2c2;
    button_conditioner p2c3;
    button_conditioner p2c4;
    
    button_conditioner startCond;
    edge_detector startDetect;
    
    
    // counters to determine when it is time to deduct score
    counter counter1(#SIZE(1), #DIV(21), .rst(dynamicRst1));
    counter counter2(#SIZE(1), #DIV(21), .rst(dynamicRst2));
    
    // counter to count down to game start
    counter startCounter(#SIZE(2), #DIV(26), .rst(startCounterRst));
    
    .rst(rst){
      // Main state machine
      fsm state = {WAIT, STARTING, CHECKZERO, CHECKZEROI, CHECKANS, CHECKANSI, SCOREMINUS, SCOREPLUS, CHECKWIN, CHECKSCOREZERO, CHECKWINI, CHECKSCOREZEROI, WIN};
      fsm player = {P1, P2}; // State to check who's turn it is
      
      dff p1Interim; // booleans to check whether players have released their buttons after a score addition/deduction
      dff p2Interim;
      
      dff winSounded; // boolean to check whether the win signal has been sent over the serial port
      
      cpu cpu16(.instr(instruction), .p1_button(p1input), .p2_button(p2input)); // CPU for computation
      
      // 7-Segment display
      multi_seven_seg seg;
      
      // random generator
      randomSet random;
      
      // USB serial port transmittion
      uart_tx tx(.block(0));
    }
  }
  
  // 7-Segment display
  dig2to1 dig2to1P1;
  dig2to1 dig2to1P2;
  
  always {
    reset_cond.in = ~rst_n; // input raw inverted reset signal
    rst = reset_cond.out;   // conditioned reset
    
    // Determine what the players are supposed to press
    p1ideal = random.out[cpu16.s1];
    p2ideal = random.out[cpu16.s2];
    
    // Display the current buttons to be pressed
    p1LED = p1ideal;
    p2LED = p2ideal;
    
    // 7-Segment display
    dig2to1P1.num = cpu16.s1;
    dig2to1P2.num = cpu16.s2;
    seg.values = c{dig2to1P1.out, dig2to1P2.out};
    io_seg = ~seg.seg;
    io_sel = ~seg.sel;
    
    // Button conditioning
    p1c1.in = ~p1Raw[0]; // Invert because buttons are connected to ground and using pullup resistors.
    p1c2.in = ~p1Raw[1];
    p1c3.in = ~p1Raw[2];
    p1c4.in = ~p1Raw[3];
    p1input = c{p1c4.out, p1c3.out, p1c2.out, p1c1.out};
    
    p2c1.in = ~p2Raw[0];
    p2c2.in = ~p2Raw[1];
    p2c3.in = ~p2Raw[2];
    p2c4.in = ~p2Raw[3];
    p2input = c{p2c4.out, p2c3.out, p2c2.out, p2c1.out};
    
    startCond.in = ~start;
    startDetect.in = startCond.out;
    
    // Reset signals for each player's counters (for detecting when their score should be deducted)
    dynamicRst1 = 0;
    dynamicRst2 = 0;
    
    // Turn off Mojo LEDs by default
    io_led = 0;
    
    instruction = 17x{b1}; // Default instruction to idle the CPU
    
    random.next = 0; // By default do not generate new numbers
    
    startCounterRst = 1; // By default, do not let the start counter run
    
    tx.data = 0; // by default do not send anything over the serial port
    tx.new_data = 0;
    avr_rx = tx.tx; // connect output of module to FPGA output
    
    // Main state machine
    case(state.q){
      state.WAIT:
        
        p1LED = 4b1111;
        p2LED = 4b1111;
        
        // TEST button connection
        io_led[3:0] = p1input;
        io_led[7:4] = p2input;
        
        random.next = 1; // Generate new numbers in the WAIT State continuously
        if(startDetect.out){
          state.d = state.STARTING;
        }
      
      state.STARTING:
        startCounterRst = 0; // Run the start counter
        
        p1LED = 0; // Don't show anything
        p2LED = 0;
        case(startCounter.value){
          0:
            seg.values = {4d3, 4d12, 4d12, 4d12};
          
          1:
            seg.values = {4d3, 4d2, 4d12, 4d12};
          
          2:
            seg.values = {4d3, 4d2, 4d1, 4d12};
          
          3:
            state.d = state.CHECKZERO;
        }
      
      state.CHECKZERO:
        case(player.q){
          player.P1:
            instruction = c{b011, 8b0, b110011};
          player.P2:
            instruction = c{b100, 8b0, b110011};
        }
        state.d = state.CHECKZEROI;
      
      state.CHECKZEROI:
        case(player.q){
          player.P1:
            if(cpu16.out){
              p1Interim.d = 0; // take player out of interim
              dynamicRst1 = 1; // reset p1 counter
              player.d = player.P2;
              state.d = state.CHECKZERO;
            } else {
              if(p1Interim.q){ // If in interim, do nothing and move on to other player.
                state.d = state.CHECKZERO;
                player.d = player.P2;
              } else {
                state.d = state.CHECKANS;
              }
            }
          
          player.P2:
            if(cpu16.out){
              p2Interim.d = 0;
              dynamicRst2 = 1;
              player.d = player.P1;
              state.d = state.CHECKZERO;
            } else {
              if(p2Interim.q){
                state.d = state.CHECKZERO;
                player.d = player.P1;
              } else {
                state.d = state.CHECKANS;
              }
            }
        }
      
      state.CHECKANS:
        case(player.q){
          player.P1:
            instruction = c{b011, b00, p1ideal, b110011};
          player.P2:
            instruction = c{b100, b00, p2ideal, b110011};
        }
        state.d = state.CHECKANSI;
      
      state.CHECKANSI:
        case(player.q){
          player.P1:
            if(cpu16.out){
              state.d = state.SCOREPLUS;
            } else {
              if(counter1.value){
                state.d = state.CHECKSCOREZERO;
              } else {
                player.d = player.P2;
                state.d = state.CHECKZERO;
              }
            }
          
          player.P2:
            if(cpu16.out){
              state.d = state.SCOREPLUS;
            } else {
              if(counter2.value){
                state.d = state.CHECKSCOREZERO;
              } else {
                player.d = player.P1;
                state.d = state.CHECKZERO;
              }
            }
        }
      
      state.SCOREPLUS:
        case(player.q){
          player.P1:
            instruction = c{b001, b01, b000001, 6x{b0}};
            p1Interim.d = 1; // put player into interim after successful addition of score.
            state.d = state.CHECKWIN;
            
            if(!tx.busy){ // Send if not busy
              tx.data = "a";
              tx.new_data = 1;
            }
          
          player.P2:
            instruction = c{b010, b10, b000001, 6x{b0}};
            p2Interim.d = 1;
            state.d = state.CHECKWIN;
            
            if(!tx.busy){
              tx.data = "b";
              tx.new_data = 1;
            }
        }
      
      state.CHECKWIN:
        case(player.q){
          player.P1:
            instruction = c{b001, b00, b010000, b110011};
          
          player.P2:
            instruction = c{b010, b00, b010000, b110011};
        }
        state.d = state.CHECKWINI;
      
      state.CHECKWINI:
        case(player.q){
          player.P1:
            if(cpu16.out){
              state.d = state.WIN;
            } else {
              player.d = player.P2;
              state.d = state.CHECKZERO;
            }
          
          player.P2:
            if(cpu16.out){
              state.d = state.WIN;
            } else {
              player.d = player.P1;
              state.d = state.CHECKZERO;
            }
        }
      
      state.WIN:
        case(player.q){
          player.P1:
            p1LED = 4x{counter1.value};
            p2LED = 0;
            //seg.values = {4d10,4d1,4d11,4d11}; // Hardcoded P1^^
            if(!tx.busy & !winSounded.q){ // Only sent if it has not been sent before. Prevent continuous sending.
              tx.data = "e";
              tx.new_data = 1;
              winSounded.d = 1;
            }
          
          player.P2:
            p2LED = 4x{counter1.value};
            p1LED = 0;
            //seg.values = {4d10,4d2,4d11,4d11}; // Hardcoded P2^^
            if(!tx.busy & !winSounded.q){
              tx.data = "f";
              tx.new_data = 1;
              winSounded.d = 1;
            }
        }
        
        if(startDetect.out){
          rst = 1;
        }
      
      state.CHECKSCOREZERO:
        case(player.q){
          player.P1:
            instruction = c{b001, b00, b000000, b110011};
            state.d = state.CHECKSCOREZEROI;
          
          player.P2:
            instruction = c{b010, b00, b000000, b110011};
            state.d = state.CHECKSCOREZEROI;
        }
      
      state.CHECKSCOREZEROI:
        case(player.q){
          player.P1:
            if(cpu16.out){
              player.d = player.P2;
              state.d = state.CHECKZERO;
            } else {
              state.d = state.SCOREMINUS;
            }
          
          player.P2:
            if(cpu16.out){
              player.d = player.P1;
              state.d = state.CHECKZERO;
            } else {
              state.d = state.SCOREMINUS;
            }
        }
      
      state.SCOREMINUS:
        case(player.q){
          player.P1:
            instruction = c{b001, b01, b000001, b000001};
            p1Interim.d = 1; // put player into interim after deduction of score.
            state.d = state.CHECKZERO;
            player.d = player.P2;
            
            if(!tx.busy){
              tx.data = "c";
              tx.new_data = 1;
            }
          
          player.P2:
            instruction = c{b010, b10, b000001, b000001};
            p2Interim.d = 1;
            state.d = state.CHECKZERO;
            player.d = player.P1;
            
            if(!tx.busy){
              tx.data = "d";
              tx.new_data = 1;
            }
        }
    }
    
    led = 0;                // not using LEDs on Mojo
    spi_miso = bz;          // not using SPI
    spi_channel = bzzzz;    // not using flags
  }
}