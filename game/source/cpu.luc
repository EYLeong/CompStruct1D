module cpu #(WIDTH=16:WIDTH>0)(
    input clk,  // clock
    input rst,  // reset
    input p1_button[4],
    input p2_button[4],
    input instr[17],
    output out[16],
    output s1[16],
    output s2[16]
  ) {
  
  sig aluResultI[WIDTH]; // Intermediate signal to hold the result from the ALU
  
  decoder2 reg_select(#WIDTH(2),
    .we_adr(instr[13:12]),
    .inp(1));
  
  register r0_reg(#WIDTH(WIDTH),
    .clk(clk),
    .rst(rst),
    .en(reg_select.o0),
    .data(aluResultI));
  
  register score1_reg(#WIDTH(WIDTH),
    .clk(clk),
    .rst(rst),
    .en(reg_select.o1),
    .data(aluResultI));
  
  register score2_reg(#WIDTH(WIDTH),
    .clk(clk),
    .rst(rst),
    .en(reg_select.o2),
    .data(aluResultI));
  
  mux8 reg_mux8(#WIDTH(WIDTH),
    .lll(r0_reg.out),
    .llh(score1_reg.out),
    .lhl(score2_reg.out),
    .lhh(c{(WIDTH-4)x{0}, p1_button}),
    .hll(c{(WIDTH-4)x{0}, p2_button}),
    .hlh(WIDTHx{0}),
    .hhl(WIDTHx{0}),
    .hhh(WIDTHx{0}),
    .select(instr[16:14]));
  
  alu alu16(#WIDTH(WIDTH),
    .a(reg_mux8.out),
    .b(c{(WIDTH - 6)x{0}, instr[11:6]}),
    .alufn(instr[5:0]));
  
  always {
    aluResultI = alu16.result;
    out = r0_reg.out;
    s1 = score1_reg.out;
    s2 = score2_reg.out;
  }
}